<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-09T14:55:35+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">기록하는 개발자</title><subtitle>기록소</subtitle><author><name>Jung MinGyu</name></author><entry><title type="html">그래프 그리기 위한것</title><link href="http://localhost:4000/%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9%EC%88%98%EC%97%85/%EC%98%A4%EC%A7%81%EB%A1%9C%EC%BB%AC/" rel="alternate" type="text/html" title="그래프 그리기 위한것" /><published>2099-09-09T00:00:00+09:00</published><updated>2099-12-31T23:13:00+09:00</updated><id>http://localhost:4000/%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9%EC%88%98%EC%97%85/%EC%98%A4%EC%A7%81%EB%A1%9C%EC%BB%AC</id><content type="html" xml:base="http://localhost:4000/%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9%EC%88%98%EC%97%85/%EC%98%A4%EC%A7%81%EB%A1%9C%EC%BB%AC/"><![CDATA[]]></content><author><name>Jung MinGyu</name></author><category term="모의해킹수업" /><category term="웹 구조" /><summary type="html"><![CDATA[오직 로컬에서만 되냐 젠장]]></summary></entry><entry><title type="html">웹서버 개발 5</title><link href="http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C5/" rel="alternate" type="text/html" title="웹서버 개발 5" /><published>2023-04-09T00:00:00+09:00</published><updated>2023-04-09T22:06:00+09:00</updated><id>http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C5</id><content type="html" xml:base="http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C5/"><![CDATA[<h3 id="post-와-get-동작-확인">POST 와 GET 동작 확인</h3>
<hr />
<ul>
  <li>GET<br /><script src="https://gist.github.com/MinGyu2/1ed4e7cc1b3cef438c72952254e3efd2.js"></script><br /><img src="https://user-images.githubusercontent.com/31990118/230756591-dd06327e-4753-456e-a601-ceb8da120991.png" alt="Pasted image 20230406195223" /></li>
  <li>POST<br /><script src="https://gist.github.com/MinGyu2/95a11b93e1f2b786ecae35f7c1b3983a.js"></script><br /><img src="https://user-images.githubusercontent.com/31990118/230756773-384d8902-197e-416d-8e87-f6e9e8bda51a.png" alt="Pasted image 20230406195234" /></li>
  <li><code class="language-plaintext highlighter-rouge">form</code> 태그 안의 <strong>action</strong> 은 목적지가 적힌다.</li>
  <li>위의 GET의 submit 버튼을 누르면 다음과 같은 링크로 이동이 된다.<br /><code class="language-plaintext highlighter-rouge">http://주소/request_get?data=test</code><br />데이터가 링크에 그대로 노출되는것을 확인할 수있다.</li>
  <li>POST의 submit 버튼을 누르면 링크는 다음과 같다.<br /><code class="language-plaintext highlighter-rouge">http://주소/request_post</code> <br />Post 방식에서는 데이터의 내용을 링크에 안보여 준다.<br />요청을 좀 더 자세히 살펴보면 (Burp suite 를 이용) 다음과 같이 전송 방식은 post이고 data에 데이터를 담아 요청을 보내는것을 확인할 수있다.<br /><img src="https://user-images.githubusercontent.com/31990118/230756791-9730f16e-8069-4a44-adc5-39173d72d07b.png" alt="Pasted image 20230406195842" /><br /><img src="https://user-images.githubusercontent.com/31990118/230756809-759edb0e-76f3-4886-a997-d526365325ae.png" alt="Pasted image 20230406195858" /></li>
</ul>

<h3 id="get-방식-데이터-서버에서-받기">GET 방식 데이터 서버에서 받기</h3>
<hr />
<ul>
  <li>servlet 을 이용하였다. <strong>doGet</strong> 함수를 Override 하여 재정의 해주었다. 그리고 uri로 <code class="language-plaintext highlighter-rouge">get</code>요청이 왔을 때 다음 사진과 같이 나오도록 하였다.<br /><img src="https://user-images.githubusercontent.com/31990118/230756827-1b50ac46-2848-416a-b4a9-46b45d62cd75.png" alt="Pasted image 20230406203701" /><br /><img src="https://user-images.githubusercontent.com/31990118/230756840-22065fec-38fe-4c64-aac6-254e28e51dfd.png" alt="Pasted image 20230406203717" /><br /><script src="https://gist.github.com/MinGyu2/485877dfa8e372b4572c970d12b29c8d.js"></script><br /><script src="https://gist.github.com/MinGyu2/074dd3e21dbed0379e4817fee80eaf24.js"></script></li>
</ul>

<h3 id="post-방식-데이터-서버에서-받기">POST 방식 데이터 서버에서 받기</h3>
<hr />
<ul>
  <li>
    <p>servlet 을 이용하였다. <strong>doPost</strong> 함수를 override 하여 재정의 해주었다. 그리고 <code class="language-plaintext highlighter-rouge">post</code> 요청이 왔을 때 다음 사진과 같이 나오도록 하였다.<br /><img src="https://user-images.githubusercontent.com/31990118/230756911-68b243b5-85e4-4560-8ae5-930bf98f913d.png" alt="Pasted image 20230409131539" /><br /><img src="https://user-images.githubusercontent.com/31990118/230756917-b9ab099c-6016-4401-844c-fe40a40a9484.png" alt="Pasted image 20230409131610" /><br /><script src="https://gist.github.com/MinGyu2/34767a4d7ae12380cb4115ded3c76132.js"></script><br /><script src="https://gist.github.com/MinGyu2/074dd3e21dbed0379e4817fee80eaf24.js"></script></p>
  </li>
  <li>
    <p>참고로 get 과 post  에서 사용하는 requestPage 부분의 함수는 같은 함수이다.</p>
  </li>
</ul>

<h3 id="참고-사이트">참고 사이트</h3>
<ul>
  <li><a href="https://lasbe.tistory.com/83">Html form 태그와 input 요소들, GET / POST 방식 (tistory.com)</a></li>
  <li><a href="https://velog.io/@jsj3282/MVC-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%842-%EB%AA%A8%EB%8D%B8-2-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-MVC-%ED%8C%A8%ED%84%B4">MVC 패턴 구현(2) : 모델 2 구조를 이용한 MVC 패턴(1)</a></li>
  <li><a href="https://initialcommit.com/blog/how-to-send-data-from-servlet-to-jsp">How to send data from Java Servlet to JSP </a></li>
</ul>]]></content><author><name>Jung MinGyu</name></author><category term="GET" /><category term="POST" /><category term="servlet" /><category term="jsp" /><category term="html" /><summary type="html"><![CDATA[get 과 post에 대해 알아보고, 직접 테스트 해보자]]></summary></entry><entry><title type="html">로그인 인증 방식</title><link href="http://localhost:4000/%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D%EB%B0%A9%EC%8B%9D/" rel="alternate" type="text/html" title="로그인 인증 방식" /><published>2023-04-08T00:00:00+09:00</published><updated>2023-04-08T22:06:00+09:00</updated><id>http://localhost:4000/%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D%EB%B0%A9%EC%8B%9D</id><content type="html" xml:base="http://localhost:4000/%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D%EB%B0%A9%EC%8B%9D/"><![CDATA[<h3 id="로그인">로그인</h3>
<ul>
  <li>웹서버는 원래 로그인이라는 기능이 없다.</li>
  <li>HTTP 프로토콜은 stateless 이다. 즉 연결성이 없다. 다시 요청을 할려면 다시 연결해야 한다. 즉 로그인 인증을 계속 해줘야한다.</li>
</ul>

<h3 id="인증-방식을-사용하는-이유">인증 방식을 사용하는 이유</h3>
<ul>
  <li>로그인을 하고 다음페이지로 이동할 때 또 로그인을 해야하는 사이트는 아주 불편할 것이다. 이러한 불편함을 없애고 사용자가 사이트 서비스를 편하게 이용하기 위해 <strong>인증 방식</strong>을 사용한다.</li>
</ul>

<h3 id="쿠키-인증-방식">쿠키 인증 방식</h3>
<hr />
<ul>
  <li>로그인 인증을 성공하면 쿠키에 인증정보를 저장한다.</li>
  <li>
    <p>이러한 쿠키와 함께 서버에 요청을 하면 로그인 인증할 필요없이 빠르게 서버와 상호작용이 가능하다.
<img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG7tgbTrnbzsnbTslrjtirgoQSkgLT4-IOyEnOuyhDogaWQsIHB3ZCDsoITshqFcbuyEnOuyhCAtPj4g7ISc67KEIDog7Jyg7Zqo7ISxIOqygOyCrFxu7ISc67KEIC0-PiDtgbTrnbzsnbTslrjtirgoQSkgOiDsnbjspp0g7ISx6rO1ICsgbG9naW5Vc2VyKEEpIOy_oO2CpFxu7YG065287J207Ja47Yq4KEEpIC0-PiDshJzrsoQgOiDsmpTssq0gKyBsb2dpblVzZXIoQSkg7L-g7YKkXG7shJzrsoQgLT4-IO2BtOudvOydtOyWuO2KuChBKSA6IOydkeuLtShBIOygleuztCkiLCJtZXJtYWlkIjpudWxsfQ" /></p>
  </li>
  <li>하지만 공격자가 <strong>쿠키변조 공격</strong>을 이용하여 로그인을 할 수있는 취약점이 있다. 즉 쿠키를 위조하면 공격자가 쉽게 로그인이 가능하다. 따라서 쿠키를 이용해서 로그인을 하는 것을 하면 안된다.</li>
</ul>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG7qs7XqsqnsnpAgLT4-IOyEnOuyhCA6IOyalOyyrSArIGxvZ2luVXNlcihBKSDsv6DtgqRcbuyEnOuyhCAtPj4g6rO16rKp7J6QIDog7J2R64u1KEEg7KCV67O0KSIsIm1lcm1haWQiOm51bGx9" /></p>

<h3 id="서버기반-인증">서버기반 인증</h3>
<hr />
<h4 id="session-방식">Session 방식</h4>
<ul>
  <li>유저의 정보를 서버에 저장한다.</li>
  <li>서버에 인증정보를 브라우저가 아닌 서버 측에 저장하고 관리한다.</li>
  <li>클라이언트의 인증 상태정보를 저장한다.</li>
</ul>

<h4 id="인증과정">인증과정</h4>
<ul>
  <li>로그인에 성공하면 서버에서 session id 를 만든다. 그리고 이 session id를 쿠키에 담아 사용자에게 보낸다.
<img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG7ruIzrnbzsmrDsoIAo7IKs7Jqp7J6QKSAtPj4gc2VydmVyIDog66Gc6re47J24IOyalOyyrVxuc2VydmVyIC0-PiBkYiA6IOuhnOq3uOyduCDsmpTssq1cbmRiIC0-PiBzZXJ2ZXIgOiDroZzqt7jsnbgg7J2R64u1XG5zZXJ2ZXIgLT4-IHNlc3Npb24g7KCA7J6l7IaMIDog7ZqM7JuQ7KCV67O0ICsgc2Vzc2lvbiBpZCDrsJzquIkg7JqU7LKtXG5zZXNzaW9uIOyggOyepeyGjCAtPj4gc2VydmVyIDogc2Vzc2lvbiBpZCDrsJzquIlcbnNlcnZlciAtPj4g67iM65287Jqw7KCAKOyCrOyaqeyekCkgOiDsnZHri7UgKyBzZXNzaW9uIGlkICjsv6DtgqTsl5Ag64Sj7Ja07IScIOyghOuLrCkiLCJtZXJtYWlkIjpudWxsfQ" /></li>
</ul>

<h4 id="session-id-를-통한-요청-과정">Session ID 를 통한 요청 과정</h4>
<ul>
  <li>서버에서 받은 session id와 요청을 서버에 보내면 서버는 session id를 이용하여 유저 정보를 획득한다.
<img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG7ruIzrnbzsmrDsoIAoY2xpZW50IEEpIC0-PiBzZXJ2ZXIgOiDsmpTssq0gKyBjb29raWUgKHNlc3Npb24gaWQpXG5zZXJ2ZXIgLT4-IHNlc3Npb24g7KCA7J6l7IaMIDogc2Vzc2lvbiBpZCDsnbjspp0g7JqU7LKtXG5zZXNzaW9uIOyggOyepeyGjCAtPj4gc2Vzc2lvbiDsoIDsnqXshowgOiDqsoDspp1cbnNlc3Npb24g7KCA7J6l7IaMIC0-PiBzZXJ2ZXIgOiDsnKDsoIAg7KCV67O0IO2ajeuTnVxuc2VydmVyIC0-PiDruIzrnbzsmrDsoIAoY2xpZW50IEEpIDog7J2R64u1IiwibWVybWFpZCI6bnVsbH0" /></li>
  <li>장점
    <ul>
      <li>각각의 사용자는 고유의 session id 를 발급받기 때문에 일일이 회원정보를 확인할 필요가 없다.</li>
      <li>강제 로그아웃, 접속 인원 제한, 로그인 된 모든 디바이스를 서버에서 쉽게 확인이 가능하다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>사용자 수가 늘어나면 session 저장소에 과부화가 걸린다.</li>
      <li>서버에서 세션 저장소를 위한 추가적인 저장공간이 필요하다.</li>
      <li>확장성이 띄어나지 않다. 서버가 늘어나면 세션 저장소를 외부로 분리하는 작업을 해야한다. 외부로 안보내면 세션 불일치 문제를 겪는다.</li>
      <li>제 3자가 session id 가 들어있는 쿠키를 탈취한 후 이 쿠키를 이용해 HTTP 요청을 보내면 서버는 사용자를 오인해 정보를 전달하게 된다.(하이재킹 공격)</li>
    </ul>
  </li>
  <li>하이재킹 공격 예방
    <ul>
      <li>HTTPS 프로토콜 사용 &amp; Session 만료시간 추가 로 어느정도 예방할 수 있다.</li>
      <li>서버 측에서 세션을 무효 처리 하면 된다.</li>
    </ul>
  </li>
</ul>

<h3 id="token-기반-인증">Token 기반 인증</h3>
<hr />
<ul>
  <li>유저의 정보를 서버에 저장하지 않는다.</li>
</ul>

<h4 id="jwt-json-web-token">JWT (JSON Web Token)</h4>
<ul>
  <li>Access Token 으로 사용된다.</li>
  <li>필요한 정보들을 암호화 시킨 토큰을 말한다.</li>
  <li>header, payload 그리고 verifiy signature 로 이루어져 있다.</li>
  <li><a href="https://jwt.io/">JSON Web Tokens - jwt.io</a><br /><img src="https://user-images.githubusercontent.com/31990118/230722780-5e188e72-e151-478a-bfb1-1b6e6b9ff7bf.png" alt="Pasted image 20230408185606" /></li>
</ul>

<h4 id="header">Header</h4>
<ul>
  <li>토큰의 타입을 나타내는 typ와 암호화할 방식을 정하는 alg으로 구성되어있다.</li>
  <li><code class="language-plaintext highlighter-rouge">alg</code> 에는 여러가지 공개키 암호화 방식중 하나의 알고리즘을 적어주면된다. (HS256, HS512, PS256 등)</li>
  <li>디코딩어 있다.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
'alg': 'HS256',
'typ': 'JWT'
}
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="payload">Payload</h4>
<ul>
  <li>토큰에 담을 정보들이 포함된다.</li>
  <li>담는 정보의 한 조각을 <strong>클레임</strong>이라 한다.</li>
  <li>노출되기 쉬움으로 민감한 정보를 담아서는 안된다. 왜냐하면 인코딩만 되어있기 때문에 쉽게 디코딩이 가능하기 때문이다. 암호화가 걸려있는 것이 아니다.</li>
  <li><strong>식별 하기 위한 정보</strong>를 담아두어야 한다.</li>
  <li>여러개의 클레임을 넣을 수 있다.
    <ul>
      <li>iss (Issuer) : 토큰 발급자</li>
      <li>sub (Subject) : 토큰 제목, 토큰에서 사용자에 대한 식별값이 됨</li>
      <li>aud(Audience) : 토큰 대상자</li>
      <li>exp (Expiration Time) : 토큰 만료 시간</li>
      <li>nbf (Not Before) : 토큰 활성 날짜</li>
      <li>iat (Issued At) : 토큰 발급 시간</li>
      <li>ti (JWT Id) : JWT 토큰 식별자</li>
      <li>위의 크레임 또는 직접 추가해도 상관 없다.
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
'iss': 'asdfasdf'
..
'my_custom': 'customm'
}
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="verify-signature">Verify Signature</h4>
<ul>
  <li>Header와 Payload가 위변조되지 않았다는 사실을 증명하는 문자열이다.</li>
  <li>Base64 로 인코딩된 header 와 payload를 합친후 비밀키로 암호화를 진행한다.</li>
  <li>암호화 알고리즘은 헤더에 적힌 알고리즘 방식을 사용해야한다.
```Verify_Signature
alg = HS256
HMACSHA256(
base64UrlEncode(header) + “.” +
base64UrlEncode(payload),
256 비밀키
)</li>
</ul>

<p>alg = PS512
RSAPSSSHA512(…)
```</p>

<h3 id="최종적으로-발급된-토큰access-token">최종적으로 발급된 토큰(Access Token)</h3>
<ul>
  <li><strong>Header.Payload.Signature</strong>  형태가 된다.<br /><img src="https://user-images.githubusercontent.com/31990118/230722926-c995599f-e18d-4786-940e-b8a4510bd256.png" alt="Pasted image 20230408191044" /></li>
  <li>제 3자가 토큰의 <code class="language-plaintext highlighter-rouge">payload 정보</code>를 변경하여 보내어도 비밀키를 알지 못하여 <code class="language-plaintext highlighter-rouge">signature 부분</code> 은 수정을 못한다. 따라서 서버는 payload에 변화가 있다는 것을 쉽게 탐지할 수 있다.</li>
</ul>

<h4 id="인증과정-1">인증과정</h4>
<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG7ruIzrnbzsmrDsoIAo7IKs7Jqp7J6QKSAtPj4g7ISc67KEIDog7IKs7Jqp7J6QIOuhnOq3uOyduCDsmpTssq1cbuyEnOuyhCAtPj4g7ZqM7JuQIERCIOyEnOuyhCA6IOuhnOq3uOyduCDsmpTssq1cbu2ajOybkCBEQiDshJzrsoQgLT4-IOyEnOuyhCA6IOuhnOq3uOyduCDsnZHri7VcbuyEnOuyhCAtPj4g7ISc67KEIDogQWNjZXNzIFRva2VuIOuwnOq4iVxu7ISc67KEIC0-PiDruIzrnbzsmrDsoIAo7IKs7Jqp7J6QKSA6IOydkeuLtSArIEFjY2VzcyBUb2tlbiAo7L-g7YKkKSIsIm1lcm1haWQiOm51bGx9" /></p>

<h4 id="발급받은-토큰을-이용한-요청-과정">발급받은 토큰을 이용한 요청 과정</h4>
<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG7ruIzrnbzsmrDsoIAo7IKs7Jqp7J6QKSAtPj4g7ISc67KEIDog7JqU7LKtICsgQWNjZXNzIFRva2VuKOy_oO2CpClcbuyEnOuyhCAtPj4g7ISc67KEIDogQWNjZXNzIFRva2VuIOqygOymnVxu7ISc67KEIC0-PiDruIzrnbzsmrDsoIAo7IKs7Jqp7J6QKSA6IOydkeuLtSIsIm1lcm1haWQiOm51bGx9" /></p>
<ul>
  <li>
    <p>Access Token 을 검증 할 때 서버의 공개키를 이용한다. <code class="language-plaintext highlighter-rouge">Verify Signature</code> 부분을 공개키로 복호화 하고 header와 payload 부분을 비교한다. 이상이 없으면 검증을 성공적으로 통과한 것이다.</p>
  </li>
  <li>장점
    <ul>
      <li>간편하다. 세션 저장소 처럼 별도의 저장소가 필요없다.</li>
      <li>JWT 발급 후 검증만 하면된다.</li>
      <li>확장성이 띄어나다. 서버가 늘어나면 세션 저장소를 외부로 분리하는 작업을 해줘야한다. 하지만 토큰은 서버에 저장을 안하여 이러한 문제로 부터 자유롭다.</li>
      <li>서버의 부담이 세션 방식보다 유리하다. 따로 저장소를 둘 필요가 없기 때문이다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>세션키와 마찬가지로 사용자 토큰을 제 3자가 훔치고, 훔친 토큰을 이용하여 HTTP 요청을 보내면 서버는 사용자를 오인해 정보를 전달하게 된다.</li>
      <li>토큰이 한번 제 3자에게 탈취되면 해당 토큰이 만료되기 전까지 속수무책으로 피해를 입을 수 밖에 없다.</li>
      <li>세션 방식보다 훨씬 더 많은 네트워크 트래픽을 사용한다. 왜냐하면 head, payload, verify signature 을 사용하여 토큰을 만들기 때문이다.</li>
    </ul>
  </li>
</ul>

<h4 id="refresh-token-을-이용한-인증과정">Refresh Token 을 이용한 인증과정</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Access Token</code> 이 탈취 당할 것을 대비하여 유효기간을 짧게 하고 <code class="language-plaintext highlighter-rouge">Access Token</code> 이 만료되었을 때 새로 발급요청하는 열쇠가 된다.</li>
  <li><strong>Refresh Token</strong> 은 긴 유효기간을 가진다.</li>
  <li>예를 들면 <code class="language-plaintext highlighter-rouge">Access Token</code> 의 유효기간은 1시간, <strong>Refresh Token</strong> 의 유효기간은 1주라 하자. 그러면 <code class="language-plaintext highlighter-rouge">Access Token</code> 이 만료되더라도, <strong>Refrech Token</strong> 을 이용하여 <code class="language-plaintext highlighter-rouge">Access Token</code>을 새롭게 발급받으면 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">Access Token</code> 과 같은 JWT 형태이다.</li>
</ul>

<p><img class="mermaid" src="https://mermaid.ink/svg/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXG7ruIzrnbzsmrDsoIAo7IKs7Jqp7J6QKSAtPj4g7ISc67KEIDog7JqU7LKtICsgQWNjZXNzIFRva2VuKOy_oO2CpClcbuyEnOuyhCAtPj4g7ISc67KEIDogQWNjZXNzIFRva2VuIOunjOujjCDtmZXsnbhcbuyEnOuyhCAtPj4g67iM65287Jqw7KCAKOyCrOyaqeyekCkgOiBBY2Nlc3MgVG9rZW4g66eM66OMIOyLoO2YuFxu67iM65287Jqw7KCAKOyCrOyaqeyekCkgLT4-IOyEnOuyhCA6IEFjY2VzcyBUb2tlbiDrsJzquIkg7JqU7LKtKCsgQWNjZXNzIFRva2VuLCBSZWZyZXNoIFRva2VuKVxu7ISc67KEIC0-PiDshJzrsoQgOiBSZWZyZXNoIFRva2VuIOqygOymnSDtm4QsIOyDiOuhnOyatCBBY2Nlc3MgVG9rZW4g67Cc6riJXG7shJzrsoQgLT4-IOu4jOudvOyasOyggCjsgqzsmqnsnpApIDog7J2R64u1ICsg7IOI66Gc7Jq0IEFjY2VzcyBUb2tlbiDrsJzquIkiLCJtZXJtYWlkIjpudWxsfQ" /></p>
<ul>
  <li>장점
    <ul>
      <li>Access Token 을 가지고 있을 때 보다 안전하다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>구현 방법이 복잡하다.</li>
      <li>Access Token 이 만료될 때마다 새롭게 발급하는 과정에거 HTTP 요청 횟수가 많아진다.</li>
    </ul>
  </li>
</ul>

<h3 id="참고-사이트">참고 사이트</h3>
<ul>
  <li><a href="https://velog.io/@adc0612/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B8%EC%A6%9D-%EC%9D%B8%EA%B0%80-Session">사용자 인증 - 세션 (velog.io)</a></li>
  <li><a href="https://velog.io/@junhok82/%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%88%EA%B9%8CCookie-Session">로그인은 어떻게 이루어질까❓(Cookie, Session) (velog.io)</a></li>
  <li><a href="https://velog.io/@dee0518/%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D">Web 로그인 인증 방식 (velog.io)</a></li>
  <li><a href="https://hudi.blog/self-made-jwt/">직접 만들어보며 이해하는 JWT (hudi.blog)</a></li>
  <li><a href="https://hudi.blog/session-based-auth-vs-token-based-auth/">세션 기반 인증과 토큰 기반 인증</a></li>
  <li><a href="https://tansfil.tistory.com/59">쉽게 알아보는 서버 인증 2편(Access Token + Refresh Token)</a></li>
  <li><a href="https://velog.io/@gusdnr814/%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%9D%B8%EC%A6%9D-4%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95#%EC%84%B8%EC%85%98%EA%B3%BC-%EC%BF%A0%ED%82%A4%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B8%EC%A6%9D">로그인 인증 4가지 방법 (velog.io)</a></li>
</ul>]]></content><author><name>Jung MinGyu</name></author><category term="cookie" /><category term="session" /><category term="token" /><summary type="html"><![CDATA[로그인 인증 방식은 여러가지가 있다.]]></summary></entry><entry><title type="html">웹서버 만들기(4)</title><link href="http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C4/" rel="alternate" type="text/html" title="웹서버 만들기(4)" /><published>2023-04-06T00:00:00+09:00</published><updated>2023-04-07T00:13:00+09:00</updated><id>http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C4</id><content type="html" xml:base="http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C4/"><![CDATA[<p><a href="https://mingyu2.github.io/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C1/">웹서버 만들기(1)</a><br />
<a href="https://mingyu2.github.io/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C2/">웹서버 만들기(2)</a><br />
<a href="https://mingyu2.github.io/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C3/">웹서버 만들기(3)</a></p>

<h3 id="오라클-db-서버-만들기">오라클 db 서버 만들기</h3>
<ul>
  <li>우분투에 설치할려 했지만 잘안되서 레트햇 호환 리눅스인 rocky os에 오라클 db를 설치하려고 한다.</li>
</ul>

<h3 id="rocky-os를-가상머신에-설치하기">Rocky OS를 가상머신에 설치하기.</h3>
<ul>
  <li>흠 … <code class="language-plaintext highlighter-rouge">Rocky 9.1</code> 을 설치하니 오라클 DB 설치가 안된다.  그래서 <strong>Rocky 8.7</strong>을 다시 설치하였다. 설치 방법은 <code class="language-plaintext highlighter-rouge">Rocky 9.1</code> 방법이랑 같다.<br /><img src="https://user-images.githubusercontent.com/31990118/230143080-62432050-0c3a-44b4-aab8-5f6e94557910.png" alt="Pasted image 20230405150704" /></li>
</ul>

<ol>
  <li>Hyper-V 에서 새 가상 컴퓨터 만들기를 진행한다.<br /><img src="https://user-images.githubusercontent.com/31990118/230143421-43da0921-f3a3-43fa-9781-8c26cbb5b58c.png" alt="Pasted image 20230405011838" /></li>
  <li>세대는 2세대로 지정하였다.<br /><img src="https://user-images.githubusercontent.com/31990118/230143523-63e397a0-dbff-407f-a620-95835287a0bd.png" alt="Pasted image 20230405011904" /></li>
  <li>메모리할당, 네트워킹 구성, 가상 하드 디스크위치를 지정하고 부팅 os를 rocky8.7.iso 로 설정하고 마침을 눌러준다.</li>
  <li>rocky os 의 가상머신이 생성된 것을 확인할 수 있다.<br /><img src="https://user-images.githubusercontent.com/31990118/230143587-a9d7a935-6dc1-477a-a755-6585304af7b5.png" alt="Pasted image 20230405011655" /></li>
  <li>rocky 가상머신을 우클릭하여 설정창에 들어가 준다. 그다음 보안 창에 들어가준다. 보안  <code class="language-plaintext highlighter-rouge">Microsoft UEFI 인증 기관</code>으로 변경하고 적용해 주자.<br /><img src="https://user-images.githubusercontent.com/31990118/230143703-cad23733-cb63-43ac-8bb0-5cd334292014.png" alt="Pasted image 20230405012353" /></li>
  <li>rocky 가상머신에 연결하고 실행하고 설치를 진행하자.<br /><img src="https://user-images.githubusercontent.com/31990118/230143808-0ce9759d-05be-46c6-85b6-81ac6a81e0c6.png" alt="Pasted image 20230405150952" /></li>
  <li>만약 <code class="language-plaintext highlighter-rouge">Failde to allocate usable memory for kernel</code> 이 발생했다면 메모리 크기를 2기가 이상으로 늘려보자. 그러면 해당 오류는 사라진다.<br /><img src="https://user-images.githubusercontent.com/31990118/230143866-02f1f570-83eb-4e60-80d6-3e35614f87dd.png" alt="Pasted image 20230405013407" /></li>
  <li>설치를 진행해주면 된다.<br /><img src="https://user-images.githubusercontent.com/31990118/230143933-58c1ca7a-59eb-4bd1-b752-ee1a7e23c12a.png" alt="Pasted image 20230405151105" /><br /><img src="https://user-images.githubusercontent.com/31990118/230143988-8fe602ca-9a5b-473d-a978-061b8a6795e4.png" alt="Pasted image 20230405151154" /></li>
  <li>설치완료<br /><img src="https://user-images.githubusercontent.com/31990118/230144158-51586520-486e-4934-95ff-153443aca8c4.png" alt="Pasted image 20230405150704" /></li>
</ol>

<h3 id="오라클-db-빠른-설치하기">오라클 DB 빠른 설치하기</h3>
<ol>
  <li>먼저 <code class="language-plaintext highlighter-rouge">oracle-database-preinstall-21c-1.0-1.el8.x86_64.rpm</code> 설치를 진행한다.<br /><script src="https://gist.github.com/MinGyu2/deb4fdd6303928ae41d118e1a525076f.js"></script><img src="https://user-images.githubusercontent.com/31990118/230144242-d9f9384b-8220-42d3-8d4c-274fec310977.png" alt="Pasted image 20230405152255" /><br /><br /><img src="https://user-images.githubusercontent.com/31990118/230144284-b5e25167-b665-4cdb-b731-deed73cf01d4.png" alt="Pasted image 20230405152725" /></li>
  <li>그리고 나서 먼저 <code class="language-plaintext highlighter-rouge">wget https://download.oracle.com/otn-pub/otn_software/db-express/oracle-database-xe-21c-1.0-1.ol8.x86_64.rpm</code>  를 통해 <code class="language-plaintext highlighter-rouge">oracle-database-xe-21c-1.0-1.ol8.x86_64.rpm</code> 를 다운받고 다음 명령을 통해 설치를 진행한다.<br /><script src="https://gist.github.com/MinGyu2/f3dd9b8f726fecf0f64ac9d7b89bf2d0.js"></script><img src="https://user-images.githubusercontent.com/31990118/230144803-6525dd61-5294-4014-8629-a48f4a645ada.png" alt="Pasted image 20230405232753" /></li>
  <li><code class="language-plaintext highlighter-rouge">/etc/init.d/oracle-xe-21c configure</code> 통해 db 서버를 동작한다. 처음 동작을 시킨다면 다음과 같이 비번을 새로 지정해 줘야 한다. <br /><img src="https://user-images.githubusercontent.com/31990118/230145159-306c415e-0f8c-412d-a3d5-a716a6345928.png" alt="Pasted image 20230405232822" /><br /><br /><img src="https://user-images.githubusercontent.com/31990118/230145206-193ab464-4ce4-4697-88f4-baf45fa1062a.png" alt="Pasted image 20230405233046" /><br />위의 주소로 접속하면 접속이 잘 안될수 있다. <br /><img src="https://user-images.githubusercontent.com/31990118/230145293-5710b599-2ba4-42a7-9522-24480d0cf2a0.png" alt="Pasted image 20230405233158" /></li>
  <li>위의 문제를 해결하기 위해서 먼저 <strong>oracl user</strong> 로 전환한다.<br /><code class="language-plaintext highlighter-rouge">su - oracle</code></li>
  <li><strong>~/.bash_profile</strong> 을 편집해야한다. 다음 내용을 추가해주자.<br /><script src="https://gist.github.com/MinGyu2/3df339b075e7106f8c3be6508da83421.js"></script></li>
  <li>현재 세션에 변화를 적용하기 위해 업데이트된 <strong>.bash_profile</strong> 을 실행하자.<br /><code class="language-plaintext highlighter-rouge">source ~/.bash_profile</code></li>
  <li>이제부터 <code class="language-plaintext highlighter-rouge">리눅스의 CLI</code> 에서 <strong>Oracle RDBMS</strong> 를 실행할 수 있다.</li>
  <li><strong>lsnrctl</strong> 명령을 통해 오라클의 상태를 확인할 수 있다.<br /><code class="language-plaintext highlighter-rouge">lsnrctl status</code><br /><img src="https://user-images.githubusercontent.com/31990118/230145612-6a6ea856-f44f-47fe-8c49-e903a41b5309.png" alt="Pasted image 20230405234130" /></li>
  <li><code class="language-plaintext highlighter-rouge">sqlplus /as sysdba</code> 를 통해 <strong>SQL 커맨드 창</strong>으로 들어갈 수 있다.<br /><img src="https://user-images.githubusercontent.com/31990118/230145691-87775cdd-f998-4023-8749-5ba0c05f8121.png" alt="Pasted image 20230405234744" /></li>
  <li><code class="language-plaintext highlighter-rouge">ss -tulpn | grep 5500</code>  명령을 통해 알아봤을 때 현재 로컬에서만 <strong>EM Express</strong> 서비스에 접속할 수있다.<br /><img src="https://user-images.githubusercontent.com/31990118/230145753-d0009039-0f85-4f00-b8cb-0003ec12659d.png" alt="Pasted image 20230405234956" /></li>
  <li><strong>SQL 커맨드 창</strong> 에서 <br /><code class="language-plaintext highlighter-rouge">EXEC DBMS_XDB.SETLISTENERLOCALACCESS(FALSE);</code><br /> 입력하면 외부에서도 접속 가능하게 된다.<br /><script src="https://gist.github.com/MinGyu2/a33780e933966e16eeb7275dbf115209.js"></script><img src="https://user-images.githubusercontent.com/31990118/230145891-bcd02f3d-6797-4ac9-b8ea-ab935192094f.png" alt="Pasted image 20230405235211" /></li>
  <li><code class="language-plaintext highlighter-rouge">https://아이피주소:5500/em</code>을 통해 접속하면 된다.<br /><img src="https://user-images.githubusercontent.com/31990118/230146140-abaea83b-5c5a-4ae2-9adb-de7ad206a40f.png" alt="Pasted image 20230405235302" /></li>
  <li>사용자이름 <code class="language-plaintext highlighter-rouge">sys</code> , 비번(우리가 지정한 비번), 컨테이너 이름 <code class="language-plaintext highlighter-rouge">cdb$root</code> 를 입력하고 로그인해주면 다음 화면이 나온다.<br /><img src="https://user-images.githubusercontent.com/31990118/230146191-30b05ff1-533b-4095-ba22-9a8cfa1e1534.png" alt="Pasted image 20230406001343" /></li>
  <li>Oracle DB 설치가 아주 잘되었다!!</li>
</ol>

<h4 id="nginx--servlet--jsp--oracle-db-구현이-완료되었다">nginx + servlet + jsp , oracle DB 구현이 완료되었다!</h4>

<h3 id="oracle-db-의-sqlplus에서-한글-깨질때">Oracle DB 의 sqlplus에서 한글 깨질때.</h3>
<ol>
  <li><strong>export NLS_LANG=KOREAN_KOREA.AL32UTF8</strong> 를 <code class="language-plaintext highlighter-rouge">.bash_profile</code> 에 추가해주면 된다.</li>
  <li>그런다음 <br /><code class="language-plaintext highlighter-rouge">source ~/.bash_profile</code><br />명령으로 <code class="language-plaintext highlighter-rouge">bash_profile</code> 을 시작해주면 된다.</li>
</ol>

<h3 id="oracle">Oracle</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">lsnrctl stop</code>,  <code class="language-plaintext highlighter-rouge">lsnrctl start</code><br /><img src="https://user-images.githubusercontent.com/31990118/230284160-75c7ed50-89c9-4a7b-a1aa-84fdfbeff56e.png" alt="Pasted image 20230406035320" />
<br /><code class="language-plaintext highlighter-rouge">nmap localhost</code></li>
  <li><code class="language-plaintext highlighter-rouge">sqlplus / as sysdba</code> 로 SQL 에 접속한다. <br /><code class="language-plaintext highlighter-rouge">startup</code> : 시작<br /><code class="language-plaintext highlighter-rouge">shutdown</code> : 중지<br /><img src="https://user-images.githubusercontent.com/31990118/230284196-83b122e4-3f46-41ad-8f31-655d2c3797c5.png" alt="Pasted image 20230406035505" />
<br /><code class="language-plaintext highlighter-rouge">nmap localhost</code></li>
</ol>

<ul>
  <li>무조건 위 순서대로 해야한다. 2 번 만하면 포트가 아무것도 안려있는것을 확인할 수 있다.</li>
</ul>

<h3 id="rocky-서버-네트워크-설정">Rocky 서버 네트워크 설정</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">nmtui</code> 를 사용한다. 고정 아이피 설정이 가능하다.</li>
</ul>

<h3 id="참고-사이트">참고 사이트</h3>
<ul>
  <li><a href="https://www.centlinux.com/2022/06/install-oracle-database-21c-xe-on-rocky-linux.html">Install Oracle Database 21c XE on Rocky Linux 8</a></li>
  <li><a href="https://www.oracle.com/kr/database/technologies/appdev/xe/quickstart.html">Oracle Database Express Edition</a></li>
  <li><a href="https://docs.rockylinux.org/guides/network/basic_network_configuration/">Network Configuration - Documentation (rockylinux.org)</a></li>
  <li><a href="https://taisou.tistory.com/622">sqlplus 에서 한글이 깨질때 (tistory.com)</a></li>
  <li><a href="https://mkil.tistory.com/336">ORACLE DB 시작 및 중지 / 리스너 시작 및 중지 하는방법 (tistory.com)</a></li>
</ul>]]></content><author><name>Jung MinGyu</name></author><category term="DB" /><summary type="html"><![CDATA[DB 설치 및 구도]]></summary></entry><entry><title type="html">웹서버 만들기(3)</title><link href="http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C3/" rel="alternate" type="text/html" title="웹서버 만들기(3)" /><published>2023-04-04T00:00:00+09:00</published><updated>2023-04-05T00:13:00+09:00</updated><id>http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C3</id><content type="html" xml:base="http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C3/"><![CDATA[<p><a href="https://mingyu2.github.io/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C1/">웹서버 만들기(1)</a><br />
<a href="https://mingyu2.github.io/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C2/">웹서버 만들기(2)</a></p>

<h3 id="servlet-에서-클라이언트에게-jsp-페이지-보여주기">Servlet 에서 클라이언트에게 JSP 페이지 보여주기</h3>
<ul>
  <li>서버 구조 ( MVC )
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>클라이언트 &lt;&gt; ningx &gt; servlet &gt; jsp
              ^─────────────────┘
</code></pre></div>    </div>
  </li>
  <li><strong>Servlet</strong> 은 controller 역할을 한다.</li>
  <li><strong>JSP</strong> 는 view 역할을 한다.</li>
</ul>

<h3 id="java-프로젝트-만들기">Java 프로젝트 만들기</h3>
<ul>
  <li>servlet 을 위한 java 프로젝트를 만들어 보자. 폴더를 다음과 같은 구조로 만들어 주자.
    <ol>
      <li>프로젝트 폴더를 생성한다.</li>
      <li><code class="language-plaintext highlighter-rouge">src/main/java</code> 폴더에 자바 소스코드 또는 패키지를 넣을 것이다.</li>
      <li><code class="language-plaintext highlighter-rouge">bin/classes</code> 폴더에 컴파일 이후의 파일을 저장할 것이다.</li>
      <li><code class="language-plaintext highlighter-rouge">lib</code> 폴더는 서드파티 라이브러리 <strong>.jar</strong> 파일을 저장하는 곳이다.</li>
    </ol>
  </li>
</ul>

<script src="https://gist.github.com/MinGyu2/83a33cde802da763e373e3fbab898e9b.js"></script>

<h3 id="servlet을-위한-java-소스코드-작성하기">Servlet을 위한 Java 소스코드 작성하기</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">cd src/main/java</code> 폴더로 이동하자.</li>
  <li>패키지 경로를 만들고 패키지 경로로 이동한다.<br /><code class="language-plaintext highlighter-rouge">src/main/java/com/example/app</code></li>
  <li><code class="language-plaintext highlighter-rouge">app</code> 폴더에 <strong>App.java</strong> 파일을 만들어준다. 그리고 다음 내용을 추가해주자.<br /><script src="https://gist.github.com/MinGyu2/9734ce99aaf29132f1078614602eec0e.js"></script></li>
  <li>컴파일하기 전 <strong>servlet-api.jar</strong> 파일을 lib 폴더에 넣어줘야한다. <code class="language-plaintext highlighter-rouge">servlet-api.jar</code> 파일은 <code class="language-plaintext highlighter-rouge">apache-tomcat-10.1.7/lib/servlet-api.jar</code> 에 있다.</li>
  <li>컴파일을 해보자. 위의 프로젝트 경로를 잘 알아두자. 자바 프로젝트의 루트 위치에서 다음 명령을 실행시켜주자.<br /><code class="language-plaintext highlighter-rouge">-cp</code> 에는 서드파티 라이브러리(.jar 파일)가 있는 경로를 적어주면 된다.<br /><code class="language-plaintext highlighter-rouge">-sourcepath</code> 는 소스코드 또는 패키지가 저장되는 경로를 적어주면된다.<br /><code class="language-plaintext highlighter-rouge">-d</code> 는 컴파일 결과가 저장되는 위치를 적어주면된다.<br /><script src="https://gist.github.com/MinGyu2/457d7264008556c6f9460276fb268718.js"></script></li>
  <li><code class="language-plaintext highlighter-rouge">bin/classes</code> 폴더안에 컴파일 결과가 저장된 것을 확인해 볼 수 있다.<br /><script src="https://gist.github.com/MinGyu2/0f410f7860e12bb3f9e9765ad2127933.js"></script></li>
</ol>

<h3 id="servlet과-jsp-동작-하기">Servlet과 Jsp 동작 하기</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">WEB-INF</code> 처음구조<br /><script src="https://gist.github.com/MinGyu2/4ac06f9d8f4e1b92cc1c7a453dca5b58.js"></script></li>
  <li><code class="language-plaintext highlighter-rouge">myWeb/ROOT/WEB-INF/classes</code> 폴더로 <code class="language-plaintext highlighter-rouge">bin/classes</code> 안에 있는 <strong>com</strong> 폴더를 옮겨주자. 그러면 <code class="language-plaintext highlighter-rouge">WEB-INF</code> 의 구조는 다음과 같다.<br />이제 사용안 할 전 <a href="https://mingyu2.github.io/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C2/">단계</a>에서 만들었던 <code class="language-plaintext highlighter-rouge">classes/App.class</code> 파일은 삭제해주자.<br /><script src="https://gist.github.com/MinGyu2/264b4f723a54dce362f9e48c1344d605.js"></script></li>
  <li>그리고 <code class="language-plaintext highlighter-rouge">WEB-INF</code> 폴더에 <strong>test.jsp</strong> 파일 만들어주자. 그리고 다음 내용을 추가해 주자.<br /><script src="https://gist.github.com/MinGyu2/caca9928fb057b6bfa231ee02c22e13c.js"></script></li>
  <li><strong>web.xml</strong> 파일도 수정해줘야 한다.  수정을 안해주면 자바 클래스를 못찾는다.<br /><img src="https://user-images.githubusercontent.com/31990118/229791396-d276256f-0643-4ce3-8980-e1a71550fd08.png" alt="Pasted image 20230404195832" /><br /><code class="language-plaintext highlighter-rouge">&lt;servlet-class&gt;App&lt;/servlet-class&gt;</code> 을 <code class="language-plaintext highlighter-rouge">&lt;servlet-class&gt;com.example.app.App&lt;/servlet-class&gt;</code> 로 변경해 줘야한다.<br /><script src="https://gist.github.com/MinGyu2/c0662d9a500b96d7fe2ead8e3a872f6f.js"></script></li>
  <li>최종적으로 나오는 <code class="language-plaintext highlighter-rouge">WEB-INF</code> 폴더의 구조는 다음과 같다.<br /><script src="https://gist.github.com/MinGyu2/e4f05014b8c6734e94f316ede76f77f3.js"></script></li>
  <li>톰캣을 재시작해주면 된다. <br /><code class="language-plaintext highlighter-rouge">./apache-tomcat-10.1.7/bin/shutdown.sh</code> 톰캣 중지<br /><code class="language-plaintext highlighter-rouge">./apache-tomcat-10.1.7/bin/startup.sh</code> 톰캣 시작<br />그리고 브라우저를 통해 <code class="language-plaintext highlighter-rouge">http://localhost</code> or <code class="language-plaintext highlighter-rouge">http://localhost:8080</code> 로 접속하면 다음과 같은 화면이 나올 것 이다.<br /><img src="https://user-images.githubusercontent.com/31990118/229791799-b7918215-2922-4d2d-b0ab-20974f0eb8cc.png" alt="Pasted image 20230404200357" /></li>
  <li>다음 구조로 서버가 동작하고 있다.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>클라이언트 &lt;&gt; ningx &gt; servlet(App.java) &gt; jsp (test.jsp)
              ^─────────────────────────────┘
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="참고사이트">참고사이트</h3>
<ul>
  <li><a href="https://velog.io/@lee_choonghee/Java-IDE-%EC%97%86%EC%9D%B4-%EA%B0%9C%EB%B0%9C%ED%95%98%EA%B8%B0">Java IDE 없이 개발하기 (velog.io)</a></li>
  <li><a href="https://stackoverflow.com/questions/22928427/how-to-redirect-to-jsp-inside-web-inf-folder">java - How to redirect to JSP inside WEB-INF folder - Stack Overflow</a></li>
  <li><a href="https://www.tutorialspoint.com/servlets/servlets-packaging.htm">Servlets - Packaging (tutorialspoint.com)</a></li>
  <li><a href="https://dololak.tistory.com/502">서블릿/JSP RequestDispatcher란. RequestDispatcher로 forward() 하기</a></li>
  <li><a href="https://initialcommit.com/blog/how-to-send-data-from-servlet-to-jsp">How to send data from Java Servlet to JSP </a></li>
</ul>]]></content><author><name>Jung MinGyu</name></author><category term="nginx" /><category term="tomcat" /><category term="servlet" /><category term="jsp" /><summary type="html"><![CDATA[간단한 로그인 서버를 만들기 (3)]]></summary></entry><entry><title type="html">웹서버 만들기(2)</title><link href="http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C2/" rel="alternate" type="text/html" title="웹서버 만들기(2)" /><published>2023-04-03T00:00:00+09:00</published><updated>2023-04-04T00:13:00+09:00</updated><id>http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C2</id><content type="html" xml:base="http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C2/"><![CDATA[<p><a href="https://mingyu2.github.io/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C1/">웹서버 만들기(1)</a></p>
<h3 id="tomcat-기본-폴더-변경">Tomcat 기본 폴더 변경</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">apache-tomcat-10.1.7/conf/server.xml</code> 에서 Host의 appBase 부분에 원하는 기본폴더 경로를 넣어주면된다.<br /><img src="https://user-images.githubusercontent.com/31990118/229538683-e88bd49c-0863-4b52-93e3-e1b8e668c13c.png" alt="Pasted image 20230403161627" /></li>
  <li>톰켓을 재시작해준다.<br /><code class="language-plaintext highlighter-rouge">./apache-tomcat-10.1.7/bin/shutdown.sh</code> 톰캣 중지<br /><code class="language-plaintext highlighter-rouge">./apache-tomcat-10.1.7/bin/startup.sh</code> 톰캣 시작</li>
  <li><code class="language-plaintext highlighter-rouge">apache-tomcat-10.1.7</code> 와 같은 위치에 <strong>myWeb</strong>  폴더를 만들어준다.<br /><img src="https://user-images.githubusercontent.com/31990118/229538804-c61cf487-ff22-4ba3-afb8-7358bd3a6fc4.png" alt="Pasted image 20230403162230" /></li>
  <li><code class="language-plaintext highlighter-rouge">myWeb</code> 폴더안에 <strong>ROOT</strong> 폴더를 만들어준다.<br /><img src="https://user-images.githubusercontent.com/31990118/229538910-1c718aca-5a81-4b2e-965e-4f0536657b41.png" alt="Pasted image 20230403162644" /></li>
  <li><code class="language-plaintext highlighter-rouge">ROOT</code> 폴더에 index.jsp 파일 만들어준다. 다음 내용을 입력해준다.
    <div class="language-jsp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;%</span> <span class="nc">String</span> <span class="n">test</span><span class="o">=</span><span class="s">"hello"</span><span class="o">;</span><span class="nt">%&gt;</span>
<span class="nt">&lt;%=</span><span class="n">test</span><span class="nt">%&gt;</span>
</code></pre></div>    </div>
  </li>
  <li>http://localhost 로 들어가면 hello 라는 문구를 출력하는 페이지를 볼 수 있다. <br /><img src="https://user-images.githubusercontent.com/31990118/229539147-895b04b6-10f6-4d36-912d-0ee78aa76b9f.png" alt="Pasted image 20230403163523" /></li>
</ol>

<h3 id="servlet">Servlet</h3>
<ul>
  <li>자바 소스코드를 컴파일하여 서버에서 사용하는 것이라 생각하면 된다.</li>
  <li>톰켓이 설치되어 있어야한다. 그리고 nginx 와 톰캣이 연동되어 있어야한다.</li>
</ul>

<ol>
  <li><strong>App.java</strong> 파일을 만들고 다음 코드를 입력해주자.
<script src="https://gist.github.com/MinGyu2/25985c0a56f4b1d065ea3728c8e2ca7b.js"></script></li>
  <li>컴파일 해보자<br /><code class="language-plaintext highlighter-rouge">javac -cp apache-tomcat-10.1.7/lib/servlet-api.jar App.java -d 출력파일위치</code><br /><strong>App.class</strong> 파일이 만들어진것을 확인할 수 있다.<br /><img src="https://user-images.githubusercontent.com/31990118/229539398-2ae422bf-460d-4391-90f9-ea0467a3676a.png" alt="Pasted image 20230403221606" /></li>
  <li>기본폴더(여기서는 myWeb 이다) <code class="language-plaintext highlighter-rouge">ROOT 폴더</code>안에 <strong>WEB-INF</strong> 폴더를 만들어주자.<br /><img src="https://user-images.githubusercontent.com/31990118/229541020-b2f57225-18a5-4b72-8380-04e778e88839.png" alt="Pasted image 20230403222333" /></li>
  <li><code class="language-plaintext highlighter-rouge">WEB-INF</code> 폴더안에 <strong>classes</strong> 폴더를 만들어주자. 이 폴더안에 앞에서 만들었던 App.class 파일을 넣을것이다.<br /><img src="https://user-images.githubusercontent.com/31990118/229541088-44173183-012a-4813-b25b-6edd46cca653.png" alt="Pasted image 20230403222739" /></li>
  <li><code class="language-plaintext highlighter-rouge">WEB-INF</code> 폴더안에 web.xml 파일을 만들어주자. 그다음 다음 내용을 추가하자. <code class="language-plaintext highlighter-rouge">web.xml</code>을 통해 Servlet을 매핑하였다.<br /><script src="https://gist.github.com/MinGyu2/d0fb4b8d208eba837b98492a0f88086d.js"></script></li>
  <li><code class="language-plaintext highlighter-rouge">http://localhost/hello</code> 로 접속하면 다음 화면이 출력되는것을 확인할 수 있다.<br /><img src="https://user-images.githubusercontent.com/31990118/229541547-b6ab7b4c-6a49-40e8-a0a9-71a96e8a507f.png" alt="Pasted image 20230403223750" /></li>
  <li>톰캣을 재시작할 필요가 있을 수 있다.<br /><code class="language-plaintext highlighter-rouge">./apache-tomcat-10.1.7/bin/shutdown.sh</code> 톰캣 중지<br /><code class="language-plaintext highlighter-rouge">./apache-tomcat-10.1.7/bin/startup.sh</code> 톰캣 시작</li>
</ol>

<h3 id="jsp">JSP</h3>
<ul>
  <li>먼저 처음에 만들어 주었던 <code class="language-plaintext highlighter-rouge">index.jsp</code> 파일을 삭제해준다.</li>
  <li><code class="language-plaintext highlighter-rouge">WEB-INF</code> 폴더안에 web.xml 파일에서 <code class="language-plaintext highlighter-rouge">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</code> 로 변경한다. 그러면 이제 <code class="language-plaintext highlighter-rouge">http://localhost</code> 로 접속하여도 다음 화면이 출려되는것을 확인할 수 있다.<br /><img src="https://user-images.githubusercontent.com/31990118/229541717-36410547-aa40-4c98-8a70-f940e314268f.png" alt="Pasted image 20230403223750" />
<script src="https://gist.github.com/MinGyu2/3a6e85f36084a036ec177160a99558f3.js"></script></li>
  <li>servlet 에서는 데이터 계산에 관련된 것만 하고 클라이언트에게 보여주는 화면은 jsp를 통해 보여줄 것이다.</li>
</ul>

<h3 id="참고-사이트">참고 사이트</h3>
<ul>
  <li><a href="https://blog.miyam.net/116">Tomcat에서 ROOT로 Context 변경하기 (miyam.net)</a></li>
  <li><a href="https://ddoongi.tistory.com/25">IDE 없이 간단한 Servlet 만들어보기 (tistory.com)</a></li>
  <li><a href="https://develop-writing.tistory.com/20">Hello Servlet! 만들어보기 (IDE 없이) (tistory.com)</a></li>
  <li><a href="https://velog.io/@jsj3282/MVC-%ED%8C%A8%ED%84%B4-%EA%B5%AC%ED%98%842-%EB%AA%A8%EB%8D%B8-2-%EA%B5%AC%EC%A1%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-MVC-%ED%8C%A8%ED%84%B4">MVC 패턴 구현(2) : 모델 2 구조를 이용한 MVC 패턴(1) (velog.io)</a></li>
  <li><a href="https://whitewing4139.tistory.com/261">2. JSP, Servlet 기본 파일 위치</a></li>
</ul>]]></content><author><name>Jung MinGyu</name></author><category term="nginx" /><category term="tomcat" /><category term="servlet" /><summary type="html"><![CDATA[간단한 로그인 서버를 만들기 (2)]]></summary></entry><entry><title type="html">웹서버 만들기(1)</title><link href="http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C1/" rel="alternate" type="text/html" title="웹서버 만들기(1)" /><published>2023-04-02T00:00:00+09:00</published><updated>2023-04-04T23:13:00+09:00</updated><id>http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C1</id><content type="html" xml:base="http://localhost:4000/%EC%9B%B9%EC%84%9C%EB%B2%84%EA%B0%9C%EB%B0%9C1/"><![CDATA[<ul>
  <li>목표 : jsp 를 이용하여 간단한 로그인 서버를 만들것이다.</li>
  <li>환경 : 우분투 22.04</li>
  <li>MVC ( Model View Controller ) 구조
    <ol>
      <li>MVC 모델1 : <code class="language-plaintext highlighter-rouge">클라이언트 &lt;&gt; 아파치 or nginx &lt;&gt; 톰캣 &lt;&gt; JSP &lt;&gt; DB</code></li>
      <li>MVC 모델2 : <code class="language-plaintext highlighter-rouge">클라이언트 &lt;&gt; 아파치 or nginx &lt;&gt; 톰캣&lt;&gt; servlet JSP &lt;&gt; DB</code></li>
    </ol>
  </li>
</ul>

<h3 id="nginx-설치하기">Nginx 설치하기</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">sudo apt install nginx</code> nginx 설치하기. <code class="language-plaintext highlighter-rouge">service nginx status</code> 로 상태를 확인할 수 있다. 설치를 하면 자동으로 동작 시작하는 것을 볼 수 있다.<br />
<code class="language-plaintext highlighter-rouge">nmap localhost</code> 로 열린 포트를 확인할 수 있다.<br />
<img src="https://user-images.githubusercontent.com/31990118/229353386-8d671b2d-95d6-4c01-a269-7d02c2752279.png" alt="Pasted image 20230402175338" /><br />
<img src="https://user-images.githubusercontent.com/31990118/229353485-fb6c96ac-1084-4585-b6cc-fdd632238fd1.png" alt="Pasted image 20230402200137" /><br />
<img src="https://user-images.githubusercontent.com/31990118/229353524-cd57db39-a86d-4b74-a57b-20c3600ad975.png" alt="Pasted image 20230402200423" /></li>
  <li>nginx 중지, 시작, 재시작 명령어.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo service nginx stop
sudo service nginx start
sudo service nginx restart
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="톰캣-설치하기">톰캣 설치하기</h3>
<ol>
  <li>톰캣 설치하기 전 <strong>open jdk 11</strong> 부터 설치한다.
<code class="language-plaintext highlighter-rouge">sudo apt install openjdk-11-jdk -y</code> 명령으로 설치한다.<br />
<img src="https://user-images.githubusercontent.com/31990118/229353590-76b89577-653b-459c-81dd-258ab4478117.png" alt="Pasted image 20230402183637" /></li>
  <li>톰캣을 설치 하기 위해 톰캣 10.0.27 버전 먼저 다운로드 받는다<br />
<code class="language-plaintext highlighter-rouge">sudo wget https://archive.apache.org/dist/tomcat/tomcat-10/v10.0.27/bin/apache-tomcat-10.0.27.tar.gz</code> 명령으로 다운받는다.<br />
<img src="https://user-images.githubusercontent.com/31990118/229353620-1052c81f-b6fc-4a5d-911b-5474c68b8c42.png" alt="Pasted image 20230402184349" /></li>
  <li>현재폴더에서 압축을 풀어준다.<br />
<code class="language-plaintext highlighter-rouge">tar -xvf apache-tomcat-10.0.27.tar.gz</code>
<img src="https://user-images.githubusercontent.com/31990118/229353642-2e0e235a-4ac4-413d-89c9-38143fb04057.png" alt="Pasted image 20230402184512" /></li>
  <li>tomcat 동작시키기.<br />
<code class="language-plaintext highlighter-rouge">./apache-tomcat-10.0.27/bin/startup.sh</code>  톰켓을 시작한다.<br />
<code class="language-plaintext highlighter-rouge">nmap localhost</code> 로 열린 포트를 확인한다<br />
<img src="https://user-images.githubusercontent.com/31990118/229353662-5fa96c01-9997-478a-9ce9-d5f8d79d5621.png" alt="Pasted image 20230402201051" /><br />
[http://localhost:8080]<br />
<img src="https://user-images.githubusercontent.com/31990118/229353695-a5d58aeb-ec1f-49a3-8eeb-32a360e1d54e.png" alt="Pasted image 20230402201102" /></li>
  <li>만약 자바를 설치하지 않았거나 JAVA_HOME 환경변수를 지정하지 않으면 오류가 발생할 수 있다. JAVA_HOME 환경변수를 등록하여 오류 해결이 가능하다.</li>
</ol>

<h3 id="nginx-와-tomcat-연동하기">NginX 와 Tomcat 연동하기</h3>
<ol>
  <li>먼저 톰켓을 동작 시켜야한다.<br />
<img src="https://user-images.githubusercontent.com/31990118/229353781-1628dd20-3a10-4b94-8887-2c1b979ee9a7.png" alt="Pasted image 20230402201051" /></li>
  <li><code class="language-plaintext highlighter-rouge">vi /etc/nginx/nginx.conf</code> 파일을 살폅보면  sites-enabled 폴더 안의 파일들을 살펴보는 것을 알 수 있다.<br />
<img src="https://user-images.githubusercontent.com/31990118/229353926-9b507926-9f5d-473d-ab29-0799a6397947.png" alt="Pasted image 20230402210019" /></li>
  <li><code class="language-plaintext highlighter-rouge">sudo vi /etc/nginx/sites-enabled/default</code> 열어보자.<br />
<img src="https://user-images.githubusercontent.com/31990118/229410744-73a7dfc8-86e8-498d-9daf-df2f8f1c7bb7.png" alt="image" /><br />
<strong>location /</strong> 의 <strong>proxy_pass</strong> 부분에 tomcat의 동작중인 주소를 넣어준다.</li>
  <li>[http://localhost] 로 접속하면 nginx로 연결되는 것이아닌 tomcat으로 연결되는것을 확인할 수 있다.
<img src="https://user-images.githubusercontent.com/31990118/229354036-affbd17e-02f9-4e49-85f5-bd2f5809c239.png" alt="Pasted image 20230402210711" /></li>
</ol>

<h3 id="nginx와-tomcat-연동중-발생한-오류">nginx와 tomcat 연동중 발생한 오류</h3>

<ul>
  <li><strong>실패1 css 파일 못찾음</strong> <br />
<img src="https://user-images.githubusercontent.com/31990118/229415729-79a7ef72-b801-49a3-83f2-84afb7b1c755.png" alt="Pasted image 20230403132740" />
<img src="https://user-images.githubusercontent.com/31990118/229415824-3200151f-5f51-4ea1-8e9d-bee2e9079f8b.png" alt="Pasted image 20230403132719" /></li>
  <li>해결법
    <ul>
      <li>방법 (1)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">/etc/nginx/sites-enabled/default</code> 파일의 <strong>location /</strong> 부분을 살펴보자.</li>
          <li><strong>try_files $uri $uri/ =404;</strong> 부분을 주석처리 안해주면 <strong>jsp</strong> 가 제대로 동작안하거나 웹사이트가 제대로 동작안 할 수 있다. 따라서 <strong>try_files $uri $uri/ =404;</strong>  부분을 주석처리해주면 된다.<br /><img src="https://user-images.githubusercontent.com/31990118/229415970-22abbd83-7558-496f-be5b-82830905b8f9.png" alt="Pasted image 20230403134856" /></li>
        </ul>
      </li>
      <li>방법(2)
        <ul>
          <li><strong>try_files $uri $uri/ =404;</strong> 을 주석처리 하지않고 .css 요청이 들어올 때도 proxy_pass 처리해 준다. <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-enabled/default</code> 파일에 넣어주면 된다.<br /><img src="https://user-images.githubusercontent.com/31990118/229416083-d35558ad-6d55-438f-8fef-d03b8a3a5cf7.png" alt="Pasted image 20230403135114" /></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>실패2 jsp는 동작은 하지만 서버가 페이지를 이상하게 만들어서줌.</strong>
<img src="https://user-images.githubusercontent.com/31990118/229416212-618480f1-fb39-418d-abb1-437ccd4cbee4.png" alt="Pasted image 20230403135438" /><br />예상동작<br /><img src="https://user-images.githubusercontent.com/31990118/229416494-f48f6664-16c2-4f1b-a82c-f4594d7b7a2c.png" alt="image" /></li>
  <li>해결법
    <ul>
      <li>방법(1)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">location ~ \.js {</code> 부분에서 <code class="language-plaintext highlighter-rouge">add_header Content-Type application/x-javascript;</code> 부분을 주석처리 해주면 된다.<br /><img src="https://user-images.githubusercontent.com/31990118/229416362-acd08166-018e-4ac8-99a6-dc07c4e4d408.png" alt="Pasted image 20230403135944" /></li>
        </ul>
      </li>
      <li>방법(2)
        <ul>
          <li><strong>try_files $uri $uri/ =404;</strong> 부분을 주석처리 안해주면 <strong>jsp</strong> 가 제대로 동작안하거나 웹사이트가 제대로 동작안 할 수 있다. 따라서 <strong>try_files $uri $uri/ =404;</strong>  부분을 주석처리해주면 된다.<br /></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>주의
    <ul>
      <li><code class="language-plaintext highlighter-rouge">default</code> 파일 바꾸고 나서 nginx 서버를 재시작해줘야 한다.<br /><code class="language-plaintext highlighter-rouge">sudo service nginx restart</code></li>
    </ul>
  </li>
</ul>

<h3 id="jsp-동작-테스트">JSP 동작 테스트</h3>
<ol>
  <li><code class="language-plaintext highlighter-rouge">apache-tomcat-10.1.7/webapps/ROOT</code> 위치에 <strong>test.jsp</strong> 파일을 만들어준다.</li>
  <li>그리고 다음 내용을 test.jsp 파일에 추가해준다.</li>
</ol>

<figure class="highlight"><pre><code class="language-jsp" data-lang="jsp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre>  <span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;%</span> <span class="nc">String</span> <span class="n">test</span><span class="o">=</span><span class="s">"hello"</span><span class="o">;</span> <span class="nt">%&gt;</span>
  <span class="nt">&lt;script&gt;</span>
          <span class="nx">alert</span><span class="p">(</span><span class="dl">'</span><span class="nt">&lt;%=</span><span class="n">test</span><span class="nt">%&gt;</span><span class="dl">'</span><span class="p">);</span>
  <span class="nt">&lt;/script&gt;</span>
  <span class="nt">&lt;/html&gt;</span>
  
</pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>동작결과<br /> <code class="language-plaintext highlighter-rouge">http://localhost/test.jsp</code> 또는 <code class="language-plaintext highlighter-rouge">http://주소/test.jsp</code> 로 들어가면 alert 창이 뜨는 것을 확인할 수 있다.<br /><img src="https://user-images.githubusercontent.com/31990118/229417802-a74e2a24-a818-483f-a0d4-16a5901817f4.png" alt="Pasted image 20230403141653" />
<br /><img src="https://user-images.githubusercontent.com/31990118/229417878-61157c2c-3e76-499e-bce9-3515112cecff.png" alt="Pasted image 20230403141721" /></li>
</ul>

<h3 id="참고-사이트">참고 사이트</h3>
<ul>
  <li><a href="https://coding-factory.tistory.com/69">Jsp MVC 패턴이란 무엇인가? (Model1, Model2)</a></li>
  <li><a href="https://seonghyuk.tistory.com/41">1. 우분투에서 아파치 웹서버 설치하기</a></li>
  <li><a href="https://doqtqu.tistory.com/103">아파치 + 톰캣 연동하기</a></li>
  <li><a href="https://haengsin.tistory.com/114?category=900169">[WEB] NginX - Tomcat 연동</a></li>
  <li><a href="https://www.hostinger.com/tutorials/how-to-install-tomcat-on-ubuntu/">Install Tomcat on Ubuntu – Simple Step-by-Step Guide (hostinger.com)</a></li>
  <li><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=heaves1&amp;logNo=221092915484">nginx설정 (Tomcat서버 요청하기) </a></li>
  <li><a href="https://www.hostinger.com/tutorials/how-to-install-tomcat-on-ubuntu/">Install Tomcat on Ubuntu – Simple Step-by-Step Guide (hostinger.com)</a></li>
  <li><a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=heaves1&amp;logNo=221092915484">nginx설정 (Tomcat서버 요청하기) </a></li>
  <li><a href="https://sangchul.kr/entry/%EB%A6%AC%EB%88%85%EC%8A%A4-nginx-tomcat-install">[리눅스] nginx tomcat 설치 및 연동</a></li>
  <li><a href="https://hiworld.tistory.com/entry/%EC%9A%B0%EB%B6%84%ED%88%AC%EB%A5%BC-%EA%B0%9C%EB%B0%9C-%EB%A8%B8%EC%8B%A0%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0-JSP-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95">우분투를 개발 머신으로 만들기 - JSP 환경 구축</a></li>
  <li><a href="https://code-monkey7.tistory.com/18">CodeMonkey :: nginX Tomcat과 nginX 연동처리를 통한 서버관리 </a></li>
</ul>]]></content><author><name>Jung MinGyu</name></author><category term="nginx" /><category term="tomcat" /><summary type="html"><![CDATA[목표 : jsp 를 이용하여 간단한 로그인 서버를 만들것이다. 환경 : 우분투 22.04 MVC ( Model View Controller ) 구조 MVC 모델1 : 클라이언트 &lt;&gt; 아파치 or nginx &lt;&gt; 톰캣 &lt;&gt; JSP &lt;&gt; DB MVC 모델2 : 클라이언트 &lt;&gt; 아파치 or nginx &lt;&gt; 톰캣&lt;&gt; servlet JSP &lt;&gt; DB]]></summary></entry><entry><title type="html">JSP, Servlet, Spring 개념</title><link href="http://localhost:4000/%EC%9B%B9%EA%B0%9C%EB%85%90/" rel="alternate" type="text/html" title="JSP, Servlet, Spring 개념" /><published>2023-04-01T00:00:00+09:00</published><updated>2023-04-01T23:13:00+09:00</updated><id>http://localhost:4000/%EC%9B%B9%EA%B0%9C%EB%85%90</id><content type="html" xml:base="http://localhost:4000/%EC%9B%B9%EA%B0%9C%EB%85%90/"><![CDATA[<h3 id="jsp--java-server-page-">JSP ( Java Server Page )</h3>
<ul>
  <li>확장자가 <strong>.jsp</strong> 인 파일이다.</li>
  <li>html 문서 안에 자바 코드를 삽해 사용할 수 있도록 해준다.</li>
  <li>동적 페이지를 제공하기 위해 사용된다.</li>
</ul>

<h3 id="servlet">servlet</h3>
<ul>
  <li>확장자가 <strong>.java</strong> 이다.</li>
  <li>자바 코드 안에 HTML을 포함하고 있다.</li>
  <li>웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다.</li>
</ul>

<h3 id="spring">Spring</h3>
<ul>
  <li>웹 어플리케이션 프레임워크이다.</li>
  <li>내부적으로 servlet 과 jsp 를 사용한다.</li>
  <li>웹 어플리케이션 관리와 개발이 간단해진다.</li>
</ul>

<h3 id="참고사이트">참고사이트</h3>
<ul>
  <li><a href="https://www.quora.com/What-is-the-difference-between-Spring-Hibernate-JSP-and-servlets">What is the difference between Spring, Hibernate, JSP, and servlets? - Quora</a></li>
  <li><a href="https://codevang.tistory.com/191">Tomcat(톰캣), JSP, Servlet(서블릿)의 기본 개념 및 구조</a></li>
  <li><a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EC%84%9C%EB%B8%94%EB%A6%BF">자바 서블릿 - 위키백과 </a></li>
</ul>]]></content><author><name>Jung MinGyu</name></author><category term="JSP" /><category term="Servlet" /><category term="Spring" /><summary type="html"><![CDATA[JSP ( Java Server Page ) 확장자가 .jsp 인 파일이다. html 문서 안에 자바 코드를 삽해 사용할 수 있도록 해준다. 동적 페이지를 제공하기 위해 사용된다.]]></summary></entry><entry><title type="html">1주차</title><link href="http://localhost:4000/%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9%EC%88%98%EC%97%85/1%EC%A3%BC%EC%B0%A8%EC%88%98%EC%97%85/" rel="alternate" type="text/html" title="1주차" /><published>2023-03-31T00:00:00+09:00</published><updated>2023-03-31T23:13:00+09:00</updated><id>http://localhost:4000/%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9%EC%88%98%EC%97%85/1%EC%A3%BC%EC%B0%A8%EC%88%98%EC%97%85</id><content type="html" xml:base="http://localhost:4000/%EB%AA%A8%EC%9D%98%ED%95%B4%ED%82%B9%EC%88%98%EC%97%85/1%EC%A3%BC%EC%B0%A8%EC%88%98%EC%97%85/"><![CDATA[<h2 id="web-service">Web Service</h2>
<ul>
  <li>네트워크 상에서 서로 다른 종류의 컴퓨터들 강에 상호작용을 하기 위한 소프트웨어 시스템이다.</li>
  <li>HTTP 프로토콜은 응답과 요청의 구조로 이용자(클라이언트) 웹서버에 요청을 하면 웹서버가 응답을 하는 구조이다.</li>
</ul>

<h3 id="동적-페이지">동적 페이지</h3>
<ul>
  <li>누가 요청하는 것에 따라 서버에서 응답이 달라진다.</li>
</ul>

<h3 id="정적-페이지">정적 페이지</h3>
<ul>
  <li>누가 요청을 하든 서버의 응답은 항상 일정하다.</li>
</ul>

<h3 id="서버-클라이언트-구조">서버-클라이언트 구조</h3>
<p><em>클라이언트 &lt;&gt; 웹서버 &lt;&gt; WAS &lt;&gt; DB 서버</em></p>

<h4 id="클라이언트">클라이언트</h4>
<ul>
  <li>PC나 스마트폰등의 사용자 측을 말한다. 사용자가 요청을 서버에 전달하기 위해 웹브라우저를 사용한다. 크롬, 파이어폭스, 사파리, 엣지등이 있다.</li>
  <li>클라이언트 측의 웹 브라우저에서 실행되는 코드를 프론트엔드라 한다. 자바스크립트가 여기에 해당한다.</li>
</ul>

<h4 id="서버">서버</h4>
<ul>
  <li><strong>웹서버</strong> : HTML로 만든 웹 페이지가 들어 있는 파일을 클라이어트에게 제공하는 것이다. <strong>아파치</strong>, <strong>nginx</strong> 등이 있다.</li>
  <li><strong>WAS</strong>(Web Application Server) : 웹 응용 프로그램이 설치되어 작동한는 웹 애플리케이션 서버를 말한다. 웹 서버와 DB 서버 사이의 미들웨어 이다. 그리고 동적 페이지를 생성하기 위한 처리를 한다.</li>
  <li><strong>DB 서버</strong> : 데이터베이스를 저장 및 관리하는 서버를 말한다.</li>
  <li>서버측에서 실행되는 코드를 백엔드라 한다. php가 여기에 해당한다.</li>
</ul>

<h3 id="url-구조">URL 구조</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">http://IP 주소 or Domain/파일경로?파라미터=1</code> 의 구조로 이루어져 있다.</li>
  <li>맨 처음을 보고 어떤 프로토콜인지 알 수 있다.(<code class="language-plaintext highlighter-rouge">http</code>, <code class="language-plaintext highlighter-rouge">https</code>, <code class="language-plaintext highlighter-rouge">ftp</code> 등)</li>
  <li><strong>파일경로</strong>는 컴퓨터의 폴더와 비슷하다고 생각하면 된다.</li>
  <li><strong>파라미터</strong>는 상자라고 생각하면 된다. 예를 들어 <code class="language-plaintext highlighter-rouge">?name=1</code> 은 name 이라는 상자에 데이터 1을 넣는 것이다.</li>
</ul>

<h3 id="http-상태-메세지">HTTP 상태 메세지</h3>

<table>
  <thead>
    <tr>
      <th>상태 메세지</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>200</td>
      <td>성공적(GOOD)</td>
    </tr>
    <tr>
      <td>300</td>
      <td>Redirect 즉 새 URL로 이동한 것 이다.</td>
    </tr>
    <tr>
      <td>400</td>
      <td>클라이언트 측 오류 메세지(요청을 잘못한 것이다.)</td>
    </tr>
    <tr>
      <td>500</td>
      <td>서버 측 오류</td>
    </tr>
  </tbody>
</table>

<h3 id="참고-사이트">참고 사이트</h3>
<ul>
  <li><a href="https://dev-youngjun.tistory.com/67">웹 시스템 WAS 원리</a></li>
  <li><a href="http://wiki.hash.kr/index.php/%EC%84%9C%EB%B2%84-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8">서버 클라이언트 구조</a></li>
  <li><a href="https://www.beusable.net/blog/?p=4507">URL 구조</a></li>
  <li><a href="https://doomed-lab.tistory.com/15">HTTP 상태 메세지 정리</a></li>
</ul>]]></content><author><name>Jung MinGyu</name></author><category term="모의해킹수업" /><category term="웹 구조" /><summary type="html"><![CDATA[Web Service 네트워크 상에서 서로 다른 종류의 컴퓨터들 강에 상호작용을 하기 위한 소프트웨어 시스템이다. HTTP 프로토콜은 응답과 요청의 구조로 이용자(클라이언트) 웹서버에 요청을 하면 웹서버가 응답을 하는 구조이다.]]></summary></entry><entry><title type="html">github.io 블로그 시작하기</title><link href="http://localhost:4000/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94/" rel="alternate" type="text/html" title="github.io 블로그 시작하기" /><published>2023-03-30T00:00:00+09:00</published><updated>2023-03-30T22:06:00+09:00</updated><id>http://localhost:4000/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94</id><content type="html" xml:base="http://localhost:4000/%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94/"><![CDATA[<p>GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.
GitHub Blog 서비스의 이름은 Pages이다.</p>

<p>Pages가 다른 블로그 플랫폼 보다 편한 것 같아서 마음에 든다.
다른 사람들도 같이 많이 사용했으면 좋겠다는 생각이 든다.</p>

<p>YFM에서 정의한 제목을 이중 괄호 구문으로 본문에 추가할 수 있다.
이 글의 제목은 github.io 블로그 시작하기이고
마지막으로 수정된 시간은 2023-03-30 08:06:00 -0500이다.</p>]]></content><author><name>Jung MinGyu</name></author><summary type="html"><![CDATA[GitHub Blog 서비스인 github.io 블로그 시작하기로 했다.]]></summary></entry></feed>